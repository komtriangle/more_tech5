

## Техническое описание сервиса:

### Бекенд:

Бекенд написал на  C# (.net7) с использованием библиотек: EntityFramewrokCore, Swashbuckle

Для хранения данных используется СУБД **PostgreSQL** с расширением **PostGIS** (для работы с пространственными данными)

Для построение маршрутов используется API GrapgHopper.



**Запуск приложения:**

Требования: наличие **docker-compose**

Скачать репозиторий

```powershell
git clone https://github.com/komtriangle/more_tech5.git
```



Перейти в нужную директорию

```powershell
cd dockerItems
```



Запустить docker-compose

```powershell
docker-compose up -d --build
```

Примечание: у вас не запустится контейнер nginx, так как его конфиг привязан к нашему доменному имени. Чтобы nginx заработал нужно заменить доменное имя.



Swagger: http://193.104.57.178:5000/swagger/index.html

В сваггере представлено описание методов апи, а так же описание запросов и ответов.



#### Алгоритм поиска оптимального отделения:

##### Введение: 

​	В отделениях банка присутствуют аппараты для выдачи талонов. Талон выдается на определенную услугу. В отделении банка есть какое-то количество работающих окон. Для каждой доступной услуги есть одно или более окон, в которых эта услуга может быть выполнена.



##### Как рассчитываем загруженность:

​	Мы рассчитываем загруженность как всего отделения, так и загруженность по отдельным услугам. Для этого мы отдельно рассчитываем загруженность каждого работающего в отделении окна.

​	В базе данных для каждого окна мы храним число минут, через сколько это станет свободно. Назовем это поле: **LeftMinutes**

- Человек получает талон на определенную услугу
- Получаем количество окон, в которые может попасть пользователь (число **n**)
- Получаем среднее время исполнения выбранной услуги в минутах (число **m**) (на основе исторических данных)
- В базе данных у каждого окна из **m** окон увеличиваем **LeftMinutes** на **m/n** минут (так как попадание в каждое из окон примерно равновероятно)
- После того как пользователя вызывают в конкретное окно - отнимаем число **m/n** из **LeftMinutes** у всех окон, кроме тех, куда вызывали пользователя
- После завершения обслуживался - отнимаем число **m/n** из **LeftMinutes** у окна, в котором обсуживался пользователь



**Как мы предоставляем пользователю загруженность по услуге:**

В момент когда пользователь хочет получить конкретную услугу в конкретном отделении, мы уже знаем ожидаемое время в очереди. Нам необходимо лишь посчитать среднее значение поля **LeftMinutes** у окон, в которых может быть выполнена услуга.

**Как мы предоставляем пользователю загруженность по всем отделению:**

 Среднее значение **LeftMinutes** окнам отделения

**Плюсы решения:**

- Быстрый ответ пользователю
- Не требует нового оборудования. Лишь интеграция с существующим



**Альтернативные решения:**

- Камеры в отделениях/загруженность по кол-ву устройств в локации: невозможно учесть услуги. Только общая загруженность отделения
- Исторические данные по дням/времени: имеют свою пользу но менее точны, не учитывают непредвиденные изменения (такие как погода или рост/падение какой-либо валюты, т.е. факторы, влияющие на загруженность)





​	

